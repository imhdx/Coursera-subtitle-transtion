该项目由一个浏览器插件和一个flask写的后台组成

## server_of_translate_and_best_jieba.py

### 环境

- python3
- flask (用来构建后台服务)
- jieba (分词，来找到更佳的断句)
- urllib (url编码)
- flask_cors （使flask允许跨域请求）
- requests （与谷歌翻译服务交互）
- re （正则表达式）
- pyOpenSSL（实现https访问，使得https的coursera可以访问后台）

### 用法

- 下载源码

- 安装python3

- 安装上述库

  ```python
  pip install pyOpenSSL
  pip install requests
  pip install flask
  pip install jieba
  pip install flask_cors
  ```

>  python3 server_of_translate_and_best_jieba.py

来启动服务

默认服务启动在https://127.0.0.2:5020

若启动在远程服务器，请把./extension/js/content.js中的127.0.0.1改成服务器的外网ip，并开放5020端口。

可使用test_flask.py来测试服务

## Coursera Subtitle Translation

开启 Coursera 课程视频的中英文双语字幕

* 如果课程同时存在中英文字幕，直接打开
* 如果课程没有中文字幕（包括zh-TW，和zh-CN），自动翻译英文字幕

### 安装

下载项目，Chrome 打开扩展程序，加载已解压的扩展程序（需要打开开发者模式）

### 使用

在上述服务启动成功后，在课程视频页面点击扩展图标即可

注意在加载出字幕后再点击图标，2-3秒后字幕翻译完成



# 思路

原字幕中，由于一句完整的英语句子会被分割成多行，而每一行又因长度多长又会被分为多行，导致逐行翻译出来的效果并不好（在谷歌翻译中，将句子用回车打断，会导致结果不一致），而粗暴的所有句子合并在一起，又会导致翻译完成的句子难以还原成对应的行，而且谷歌翻译一次只能接收5000字符以下。

故将一边将每一行合并，同时检测当前是否为句子结尾，是的话便记录句子开头是哪一行。这样一个句子大约会有少数几个行组成，也便于将翻译结果还原到对应的行。

为减少调用谷歌翻译API的次数（提升速度，减少BAN的风险），将句子合并成少于5000字符的字符串，用两个回车符来连接。

在将句子的翻译还原成对应的行时，若粗暴地用对应英文的长度等比例来分割，会导致中文中完整的词被一分为二，同样会减少可读性。考虑分词，用粒度为词的句子来被分割，效果会好很多。

句子被分割好后，有部分标点符号会出现在句子的头部，减少可读性，故做进一步的处理。

# TODO

- 分词只考虑了中文分词，其实将英文也可分词，这样全部用词的粒度来计算比例，应该会有更好的效果。

- 谷歌翻译相对DeepL翻译效果还是差一点，后续考虑更换成DeepL。

- 由于有分词，故将主要操作移至后台，考虑用其他方法获得更好的分割效果，最好在前端实现。

有的句子如

> 1
> 00:00:00.025 --> 00:00:04.097
> [SOUND] Diabetes is a serious and
>
> 2
> 00:00:04.097 --> 00:00:08.796
> fast growing health problem in most
>
> 3
> 00:00:08.796 --> 00:00:14.131
> countries in the world, rich and poor.

翻译成中文为

>1 [声音]在世界上大多数国家，
>2 无论贫富，糖尿病都是
>3 一个严重且快速增长的健康问题。

可以发现中文的顺序和英文并不一致，这样哪怕有更好分割方法，也无法处理的比较完美。

可对比字幕组给出的翻译，通过调换中文的顺序使其与英文的顺序一致（难实现！），（不过好像字幕组翻译出来的效果差点。。

>1
>00:00:00.025 --> 00:00:04.097
>[声音]糖尿病是一个严重而且
>
>2
>00:00:04.097 --> 00:00:08.796
>快速增长的健康问题
>
>3
>00:00:08.796 --> 00:00:14.131
>在世界上大多数国家，有富裕的也有和贫穷的。